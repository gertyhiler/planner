# 🏗️ Архитектура проекта

## Обзор

Planner - это планировщик задач с поддержкой web, desktop и mobile приложений, построенный на принципах единой бизнес-логики и автоматической синхронизации.

## Архитектурные принципы

### 1. **Spec-First подход**

- API описывается через OpenAPI схему
- Автоматическая генерация типов и клиентов
- Единая валидация для всех приложений

### 2. **Единая бизнес-логика**

- Вся логика работы с данными в `@planner/database`
- Переиспользование кода между всеми приложениями
- Централизованная поддержка и развитие

### 3. **Офлайн-первый**

- Desktop/mobile работают без интернета
- Локальная SQLite база данных
- Автоматическая синхронизация при подключении

### 4. **Типобезопасность**

- TypeScript во всех пакетах
- Общие типы для всех приложений
- Автодополнение и проверка на этапе компиляции

## Структура пакетов

```
@planner/database/     # 🗄️ Центральная бизнес-логика
├── BaseService       # Общая логика CRUD
├── TaskService       # Логика задач
├── ProjectService    # Логика проектов
├── AreaService       # Логика областей
├── UserService       # Логика пользователей
└── SyncManager       # Синхронизация

@planner/backend/      # 🔌 API сервер
├── Sync API          # Синхронизация для desktop/mobile
├── Web API           # API для web приложения
├── Auth API          # Аутентификация
└── Database          # Работа с облачной БД

@planner/api-schema/   # 📋 OpenAPI схема
├── OpenAPI spec      # Описание API
├── TypeScript types  # Типы для API
└── Validation        # Валидация запросов/ответов

@planner/api-client/   # 🌐 SDK для web
├── HTTP client       # Клиент для API
├── Auth client       # Аутентификация
└── TypeScript API    # Типизированные методы

@planner/ui-kit/       # 🎨 Общий UI Kit
├── Components        # React компоненты
├── Hooks            # React hooks
├── Styles           # CSS/Tailwind стили
└── Icons            # Иконки

@planner/web/          # 🌍 Web приложение (тонкий клиент)
├── Thin client      # Только API вызовы
├── UI Kit usage     # Использование UI Kit
└── Next.js          # React framework

@planner/app/          # 💻 Desktop приложение (толстый клиент)
├── Thick client     # Локальная БД + синхронизация
├── UI Kit usage     # Использование UI Kit
└── Electron         # Desktop framework

@planner/mobile/       # 📱 Mobile приложение (толстый клиент)
├── Thick client     # Локальная БД + синхронизация
├── UI Kit usage     # Использование UI Kit
└── React Native     # Mobile framework
```

## Потоки данных

### Web приложение (тонкий клиент)

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Web App   │───▶│ API Client  │───▶│   Backend   │───▶│ PostgreSQL  │
│             │    │             │    │             │    │   (Cloud)   │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

### Desktop/Mobile приложения (толстые клиенты)

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│Desktop/Mobile│───▶│Database SDK │───▶│ SQLite      │
│             │    │             │    │ (Local)     │
└─────────────┘    └─────────────┘    └─────────────┘
       │                   │                   │
       │                   ▼                   │
       │            ┌─────────────┐            │
       └───────────▶│Sync Manager │◀───────────┘
                    └─────────────┘
                           │
                           ▼
                    ┌─────────────┐    ┌─────────────┐
                    │   Backend   │───▶│ PostgreSQL  │
                    │             │    │   (Cloud)   │
                    └─────────────┘    └─────────────┘
```

## База данных

### Поддерживаемые БД

- **SQLite** - для desktop/mobile приложений (локальная)
- **PostgreSQL** - для web приложения и backend (облачная)

### Схема БД

```prisma
// Основные сущности
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  // ... другие поля
}

model Task {
  id          String   @id @default(cuid())
  name        String
  description String?
  status      TaskStatus
  priority    Priority
  // ... другие поля

  // Поля для синхронизации
  syncId      String?  @unique
  lastSync    DateTime?
  isDeleted   Boolean  @default(false)
  version     Int      @default(1)
}

// Лог синхронизации
model SyncLog {
  id         String   @id @default(cuid())
  entityId   String
  entityType String
  operation  String
  data       String   // JSON
  timestamp  DateTime @default(now())
  synced     Boolean  @default(false)
}
```

## Синхронизация

### Принципы

1. **Офлайн-первый** - все операции выполняются локально
2. **Автоматическая синхронизация** - при наличии интернета
3. **Конфликт-резолюшен** - последний выигрывает
4. **Версионирование** - каждое изменение увеличивает версию

### Процесс синхронизации

1. **Локальные изменения** логируются в `SyncLog`
2. **Автоматическая синхронизация** каждые 30 секунд
3. **Загрузка изменений** на сервер через API
4. **Скачивание изменений** с сервера
5. **Применение изменений** к локальной БД
6. **Разрешение конфликтов** по версиям

## API

### Эндпоинты для web приложения

```
GET    /api/tasks          # Получение задач
POST   /api/tasks          # Создание задачи
PUT    /api/tasks/:id      # Обновление задачи
DELETE /api/tasks/:id      # Удаление задачи

GET    /api/projects       # Получение проектов
POST   /api/projects       # Создание проекта

GET    /api/areas          # Получение областей
POST   /api/areas          # Создание области
```

### Эндпоинты для синхронизации

```
POST   /api/sync/upload    # Загрузка изменений
GET    /api/sync/download  # Скачивание изменений
GET    /api/sync/status    # Статус синхронизации
```

## Безопасность

### Аутентификация

- JWT токены для всех API запросов
- Bearer token в заголовке Authorization
- Автоматическое обновление токенов

### Валидация

- OpenAPI схема для валидации запросов/ответов
- Zod схемы для runtime валидации
- TypeScript для compile-time проверки типов

## Производительность

### Оптимизации

- Кэширование на уровне приложений
- Ленивая загрузка компонентов
- Оптимизированные SQL запросы
- Сжатие данных при синхронизации

### Мониторинг

- Логирование всех операций
- Метрики производительности
- Отслеживание ошибок
- Мониторинг синхронизации

## Развертывание

### Backend

- Docker контейнеры
- Kubernetes для масштабирования
- PostgreSQL в облаке
- CDN для статических файлов

### Web приложение

- Vercel/Netlify для хостинга
- SSR/SSG для производительности
- PWA для офлайн-режима

### Desktop приложение

- Electron для кроссплатформенности
- Автообновления через GitHub Releases
- Подписанные установщики

### Mobile приложение

- React Native для кроссплатформенности
- App Store/Google Play для распространения
- Push уведомления

## Преимущества архитектуры

### 1. **Единообразие**

- Одинаковая логика во всех приложениях
- Общие типы и интерфейсы
- Единые правила валидации

### 2. **Переиспользование**

- Один код для всех платформ
- Общие утилиты и хелперы
- Централизованная бизнес-логика

### 3. **Поддержка**

- Изменения в одном месте
- Легкое тестирование
- Простое добавление новых функций

### 4. **Типобезопасность**

- Общие типы для всех приложений
- Автодополнение в IDE
- Проверка типов на этапе компиляции

### 5. **Синхронизация**

- Автоматическая синхронизация
- Офлайн-режим
- Разрешение конфликтов

## Заключение

Данная архитектура обеспечивает максимальную гибкость, переиспользование кода и масштабируемость проекта. Единая бизнес-логика в `@planner/database` позволяет быстро развивать функциональность для всех платформ одновременно, а система синхронизации обеспечивает бесшовную работу пользователей между устройствами.
